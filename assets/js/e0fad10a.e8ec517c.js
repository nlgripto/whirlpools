"use strict";(self.webpackChunk_orca_so_whirlpools_docs=self.webpackChunk_orca_so_whirlpools_docs||[]).push([[8671],{95:(e,t,n)=>{n.d(t,{A:()=>j});var i=n(4041),o=n(4357),s=n(5245),r=n(6090),a=n(3190),l=n(838),u=n(6423),c=n(6326);function d(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:i,default:o}}=e;return{value:t,label:n,attributes:i,default:o}}))}(n);return function(e){const t=(0,u.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const o=(0,r.W6)(),s=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(s),(0,i.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(o.location.search);t.set(s,e),o.replace({...o.location,search:t.toString()})}),[s,o])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:o}=e,s=h(e),[r,l]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:t,tabValues:s}))),[u,d]=f({queryString:n,groupId:o}),[g,m]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,s]=(0,c.Dv)(n);return[o,(0,i.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:o}),v=(()=>{const e=u??g;return p({value:e,tabValues:s})?e:null})();(0,a.A)((()=>{v&&l(v)}),[v]);return{selectedValue:r,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),m(e)}),[d,m,s]),tabValues:s}}var m=n(1310);const v={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};var w=n(1085);function b(e){let{className:t,block:n,selectedValue:i,selectValue:r,tabValues:a}=e;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.a_)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),o=a[n].value;o!==i&&(u(t),r(o))},d=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},t),children:a.map((e=>{let{value:t,label:n,attributes:s}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...s,className:(0,o.A)("tabs__item",v.tabItem,s?.className,{"tabs__item--active":i===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:s}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===s));return e?(0,i.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==s})))})}function x(e){const t=g(e);return(0,w.jsxs)("div",{className:(0,o.A)("tabs-container",v.tabList),children:[(0,w.jsx)(b,{...t,...e}),(0,w.jsx)(y,{...t,...e})]})}function j(e){const t=(0,m.A)();return(0,w.jsx)(x,{...e,children:d(e.children)},String(t))}},1184:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(4041);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},4435:(e,t,n)=>{n.d(t,{A:()=>r});n(4041);var i=n(4357);const o={tabItem:"tabItem_OMyP"};var s=n(1085);function r(e){let{children:t,hidden:n,className:r}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,i.A)(o.tabItem,r),hidden:n,children:t})}},5286:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Whirlpools SDKs/Whirlpools/Position Management/Harvest","title":"Harvesting a Position","description":"Harvesting a position in Orca Whirlpools allows you to collect any accumulated fees and rewards without closing the position. This process is useful when you want to claim your earnings while keeping your liquidity active in the pool, ensuring you continue to benefit from potential future fees.","source":"@site/docs/03-Whirlpools SDKs/01-Whirlpools/04-Position Management/04-Harvest.mdx","sourceDirName":"03-Whirlpools SDKs/01-Whirlpools/04-Position Management","slug":"/Whirlpools SDKs/Whirlpools/Position Management/Harvest","permalink":"/Whirlpools SDKs/Whirlpools/Position Management/Harvest","draft":false,"unlisted":false,"editUrl":"https://github.com/orca-so/whirlpools/tree/main/docs/whirlpool/docs/03-Whirlpools SDKs/01-Whirlpools/04-Position Management/04-Harvest.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_label":"Harvest"},"sidebar":"sidebar","previous":{"title":"Adjust Liquidity","permalink":"/Whirlpools SDKs/Whirlpools/Position Management/Adjust Liquidity"},"next":{"title":"Close Position","permalink":"/Whirlpools SDKs/Whirlpools/Position Management/Close Position"}}');var o=n(1085),s=n(1184),r=n(95),a=n(4435);const l={sidebar_label:"Harvest"},u="Harvesting a Position",c={},d=[{value:"1. Overview of Harvesting a Position",id:"1-overview-of-harvesting-a-position",level:2},{value:"2. Getting Started Guide",id:"2-getting-started-guide",level:2},{value:"Step-by-Step Guide to Harvesting a Position",id:"step-by-step-guide-to-harvesting-a-position",level:3},{value:"3. Usage Example",id:"3-usage-example",level:2},{value:"4. Next Steps",id:"4-next-steps",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"harvesting-a-position",children:"Harvesting a Position"})}),"\n",(0,o.jsx)(t.p,{children:"Harvesting a position in Orca Whirlpools allows you to collect any accumulated fees and rewards without closing the position. This process is useful when you want to claim your earnings while keeping your liquidity active in the pool, ensuring you continue to benefit from potential future fees."}),"\n",(0,o.jsx)(t.h2,{id:"1-overview-of-harvesting-a-position",children:"1. Overview of Harvesting a Position"}),"\n",(0,o.jsx)(t.p,{children:"The SDK helps you generate the instructions needed to collect fees and rewards from a position without closing it. This allows you to realize your earnings while maintaining liquidity in the pool."}),"\n",(0,o.jsx)(t.p,{children:"With this function, you can:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Collect accumulated trading fees from your position."}),"\n",(0,o.jsx)(t.li,{children:"Harvest rewards earned by providing liquidity, all while keeping the position active."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"2-getting-started-guide",children:"2. Getting Started Guide"}),"\n",(0,o.jsx)(t.h3,{id:"step-by-step-guide-to-harvesting-a-position",children:"Step-by-Step Guide to Harvesting a Position"}),"\n",(0,o.jsx)(t.p,{children:"To harvest fees and rewards from a position, follow these steps:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"RPC Client"}),": Use a Solana RPC client to interact with the blockchain."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Position Mint"}),": Provide the mint address of the NFT representing your position. This NFT serves as proof of ownership and represents the liquidity in the position."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Authority"}),": This can be your wallet, which will fund the pool initialization. If the authority is not specified, the default wallet will be used. You can configure the default wallet through the SDK."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Create Instructions"}),": Use the appropriate function to generate the necessary instructions to harvest fees and rewards."]}),"\n"]}),"\n",(0,o.jsxs)(r.A,{groupId:"programming-languages",children:[(0,o.jsx)(a.A,{value:"ts",label:"Typescript",default:!0,children:(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:"import { harvestPositionInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\nimport { createSolanaRpc, devnet, address } from '@solana/kit';\nimport { loadWallet } from './utils';\n\nawait setWhirlpoolsConfig('solanaDevnet');\nconst devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\nconst wallet = await loadWallet();\nconst positionMint = address(\"HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K\");\n\nconst { feesQuote, rewardsQuote, instructions } = await harvestPositionInstructions(\n  devnetRpc,\n  positionMint,\n  wallet\n);\n\nconsole.log(`Fees owed token A: ${feesQuote.feeOwedA}`);\nconsole.log(`Rewards '1' owed: ${rewardsQuote.rewards[0].rewardsOwed}`);\n"})})}),(0,o.jsx)(a.A,{value:"rust",label:"Rust",children:(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:'use orca_whirlpools::{\n    harvest_position_instructions, set_whirlpools_config_address, WhirlpoolsConfigInput,\n};\nuse solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_sdk::pubkey::Pubkey;\nuse std::str::FromStr;\nuse crate::utils::load_wallet;\n\n#[tokio::main]\nasync fn main() {\n    set_whirlpools_config_address(WhirlpoolsConfigInput::SolanaDevnet).unwrap();\n    let rpc = RpcClient::new("https://api.devnet.solana.com".to_string());\n    let wallet = load_wallet();\n\n    let position_mint_address =\n        Pubkey::from_str("HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K").unwrap();\n\n    let result = harvest_position_instructions(&rpc, position_mint_address, Some(wallet.pubkey()))\n        .await\n        .unwrap();\n\n    println!("Fees Quote: {:?}", result.fees_quote);\n    println!("Rewards Quote: {:?}", result.rewards_quote);\n    println!("Number of Instructions: {}", result.instructions.len());\n}\n'})})})]}),"\n",(0,o.jsxs)(t.ol,{start:"5",children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Submit Transaction"}),": Include the generated instructions in a Solana transaction and send it to the network using the Solana SDK."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"3-usage-example",children:"3. Usage Example"}),"\n",(0,o.jsx)(t.p,{children:"Suppose you are a developer creating a bot to manage investments for a group of investors. The bot periodically collects accumulated fees and rewards from liquidity positions to distribute profits among investors. By using the SDK, you can generate the instructions to collect earnings from each active position without closing it, allowing the liquidity to continue generating returns and potentially reinvest your earned fees into the position."}),"\n",(0,o.jsx)(t.h2,{id:"4-next-steps",children:"4. Next Steps"}),"\n",(0,o.jsx)(t.p,{children:"After harvesting fees and rewards, you can:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"/Whirlpools%20SDKs/Whirlpools/Position%20Management/Fetch%20Positions",children:"Monitor Performance"}),": Keep track of your position to evaluate future earnings and the overall performance."]}),"\n",(0,o.jsx)(t.li,{children:"Reinvest Earnings: Use the harvested fees and rewards to add more liquidity or diversify your positions."}),"\n",(0,o.jsx)(t.li,{children:"Harvest Regularly: Regularly collect your earnings to maintain optimal capital efficiency while keeping your liquidity active."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"By using the SDK, you can maximize the benefits of providing liquidity while keeping your position open and continuously earning fees."})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);