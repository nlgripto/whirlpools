"use strict";(self.webpackChunk_orca_so_whirlpools_docs=self.webpackChunk_orca_so_whirlpools_docs||[]).push([[9385],{95:(e,n,t)=>{t.d(n,{A:()=>y});var s=t(4041),a=t(4357),i=t(5245),r=t(6090),o=t(3190),l=t(838),c=t(6423),d=t(6326);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:a}}=e;return{value:n,label:t,attributes:s,default:a}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(a.location.search);n.set(i,e),a.replace({...a.location,search:n.toString()})}),[i,a])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,i=h(e),[r,l]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i}))),[c,u]=p({queryString:t,groupId:a}),[g,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,i]=(0,d.Dv)(t);return[a,(0,s.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:a}),x=(()=>{const e=c??g;return m({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{x&&l(x)}),[x]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,i]),tabValues:i}}var f=t(1310);const x={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};var b=t(1085);function w(e){let{className:n,block:t,selectedValue:s,selectValue:r,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),a=o[t].value;a!==s&&(c(n),r(a))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>{l.push(e)},onKeyDown:u,onClick:d,...i,className:(0,a.A)("tabs__item",x.tabItem,i?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:i}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===i));return e?(0,s.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function j(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,a.A)("tabs-container",x.tabList),children:[(0,b.jsx)(w,{...n,...e}),(0,b.jsx)(v,{...n,...e})]})}function y(e){const n=(0,f.A)();return(0,b.jsx)(j,{...e,children:u(e.children)},String(n))}},1023:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"Whirlpools SDKs/Whirlpools/Send Transaction","title":"Sending and Landing Transactions","description":"In this guide, we\'ll explore how to send the instructions using the Solana SDK - both in Typescript and Rust. We\'ll cover the following key topics:","source":"@site/docs/03-Whirlpools SDKs/01-Whirlpools/06-Send Transaction.mdx","sourceDirName":"03-Whirlpools SDKs/01-Whirlpools","slug":"/Whirlpools SDKs/Whirlpools/Send Transaction","permalink":"/Whirlpools SDKs/Whirlpools/Send Transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/orca-so/whirlpools/tree/main/docs/whirlpool/docs/03-Whirlpools SDKs/01-Whirlpools/06-Send Transaction.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_label":"Send Transactions"},"sidebar":"sidebar","previous":{"title":"Trade","permalink":"/Whirlpools SDKs/Whirlpools/Trade"},"next":{"title":"Whirlpools Core","permalink":"/Whirlpools SDKs/Whirlpools Core"}}');var a=t(1085),i=t(1184),r=t(95),o=t(4435);const l={sidebar_label:"Send Transactions"},c="Sending and Landing Transactions",d={},u=[{value:"Code Overview",id:"code-overview",level:2},{value:"1. Dependencies",id:"1-dependencies",level:3},{value:"2. Create Transaction Message From Instructions",id:"2-create-transaction-message-from-instructions",level:3},{value:"3. Estimating Compute Unit Limit and Prioritization Fee",id:"3-estimating-compute-unit-limit-and-prioritization-fee",level:3},{value:"4. Sign and Submit Transaction",id:"4-sign-and-submit-transaction",level:3},{value:"Handling transactions with Wallets in web apps.",id:"handling-transactions-with-wallets-in-web-apps",level:2},{value:"Creating Noop Signers",id:"creating-noop-signers",level:4},{value:"Prioritization Fees",id:"prioritization-fees",level:4},{value:"Additional Improvements for Landing Transactions",id:"additional-improvements-for-landing-transactions",level:2}];function h(e){const n={a:"a",annotation:"annotation",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"sending-and-landing-transactions",children:"Sending and Landing Transactions"})}),"\n",(0,a.jsx)(n.p,{children:"In this guide, we'll explore how to send the instructions using the Solana SDK - both in Typescript and Rust. We'll cover the following key topics:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Client-side retry"}),"\n",(0,a.jsx)(n.li,{children:"Prioritization fees"}),"\n",(0,a.jsx)(n.li,{children:"Compute budget estimation"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"We also cover key considerations for sending transactions in web applications with wallet extensions, along with additional steps to improve transaction landing."}),"\n",(0,a.jsxs)(n.p,{children:["Make sure you check out ",(0,a.jsx)(n.a,{href:"/Whirlpools%20SDKs/Whirlpools/Environment%20Setup",children:"this doc"})," to set up your environment."]}),"\n",(0,a.jsx)(n.h2,{id:"code-overview",children:"Code Overview"}),"\n",(0,a.jsx)(n.h3,{id:"1-dependencies",children:"1. Dependencies"}),"\n",(0,a.jsx)(n.p,{children:"Let's start by importing the necessary dependencies from Solana's SDKs."}),"\n",(0,a.jsxs)(r.A,{groupId:"programming-languages",children:[(0,a.jsxs)(o.A,{value:"ts",label:"Typescript",default:!0,children:[(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"dependencies": {\n  "@solana-program/compute-budget": "^0.6.1",\n  "@solana/kit": "^2.1.0",\n},\n'})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"import {\n  createSolanaRpc,\n  address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  prependTransactionMessageInstructions,\n  signTransactionMessageWithSigners,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  getBase64EncodedWireTransaction,\n  setTransactionMessageFeePayerSigner\n} from '@solana/kit';\nimport {\n  getSetComputeUnitLimitInstruction,\n  getSetComputeUnitPriceInstruction\n} from '@solana-program/compute-budget';\n"})})]}),(0,a.jsxs)(o.A,{value:"rust",label:"Rust",children:[(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",metastring:'title="Cargo.toml"',children:'serde_json = { version = "^1.0" }\nsolana-client = { version = "^1.18" }\nsolana-sdk = { version = "^1.18" }\ntokio = { version = "^1.41.1" }\n'})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:"use solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_client::rpc_config::RpcSendTransactionConfig;\nuse solana_sdk::commitment_config::CommitmentLevel;\nuse solana_sdk::compute_budget::ComputeBudgetInstruction;\nuse solana_sdk::message::Message;\nuse solana_sdk::pubkey::Pubkey;\nuse solana_sdk::signature::Signature;\nuse solana_sdk::transaction::Transaction;\nuse solana_sdk::{signature::Keypair, signer::Signer};\nuse std::fs;\nuse std::str::FromStr;\nuse tokio::time::{sleep, Duration, Instant};\n"})})]})]}),"\n",(0,a.jsx)(n.h3,{id:"2-create-transaction-message-from-instructions",children:"2. Create Transaction Message From Instructions"}),"\n",(0,a.jsx)(n.p,{children:"To send a transaction on Solana, you need to include a blockhash to the transaction. A blockhash acts as a timestamp and ensures the transaction has a limited lifetime. Validators use the blockhash to verify the recency of a transaction before including it in a block. A transaction referencing a blockhash is only valid for 150 blocks (~1-2 minutes, depending on slot time). After that, the blockhash expires, and the transaction will be rejected."}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Durable Nonces"}),": In some cases, you might need a transaction to remain valid for longer than the typical blockhash lifespan, such as when scheduling future payments or collecting multi-signature approvals over time. In that case, you can use ",(0,a.jsx)(n.a,{href:"https://solana.com/developers/courses/offline-transactions/durable-nonces",children:"durable nonces"})," to sign the transaction, which includes a nonce in place of a recent blockhash."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["You also need to add the signers to the transactions. With Solana Kit, you can create instructions and add additional signers as ",(0,a.jsx)(n.code,{children:"TransactionSigner"})," to the instructions. The Typescript Whirlpools SDK leverages this functioanlity and appends all additional signers to the instructions for you. In Rust, this feautures is not available. Therefore, the Rust Whirlpools SDK may return ",(0,a.jsx)(n.code,{children:"instruction_result.additional_signers"})," if there are any, and you need to manually append them to the transaction."]}),"\n",(0,a.jsx)(n.p,{children:"Here's how the transaction message is created:"}),"\n",(0,a.jsxs)(r.A,{groupId:"programming-languages",children:[(0,a.jsx)(o.A,{value:"ts",label:"Typescript",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"const { instructions } = // get instructions from Whirlpools SDK\nconst latestBlockHash = await rpc.getLatestBlockhash().send();\nconst transactionMessage = await pipe(\n  createTransactionMessage({ version: 0}),\n  tx => setTransactionMessageFeePayer(wallet.address, tx),\n  tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockHash.value, tx),\n  tx => appendTransactionMessageInstructions(instructions, tx)\n)\n"})})}),(0,a.jsx)(o.A,{value:"rust",label:"Rust",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:"#[tokio::main]\nasync fn main() {\n  // ...\n  let instructions_result = // get instructions from Whirlpools SDK\n  let message = Message::new(\n    &instructions_result.instructions,\n    Some(&wallet.pubkey()),\n  );\n  let mut signers: Vec<&dyn Signer> = vec![&wallet];\n  signers.extend(\n    instructions_result\n      .additional_signers\n      .iter()\n      .map(|kp| kp as &dyn Signer),\n  );\n  let recent_blockhash = rpc.get_latest_blockhash().await.unwrap();\n  let transaction = Transaction::new(&signers, message, recent_blockhash);\n  // ...\n}\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"3-estimating-compute-unit-limit-and-prioritization-fee",children:"3. Estimating Compute Unit Limit and Prioritization Fee"}),"\n",(0,a.jsx)(n.p,{children:"Before sending a transaction, it's important to set a compute unit limit and an appropriate prioritization fee."}),"\n",(0,a.jsx)(n.p,{children:"Transactions that request fewer compute units get high priority for the same amount of prioritization fee (which is defined per compute unit). Setting the compute units too low will result in a failed transaction."}),"\n",(0,a.jsx)(n.p,{children:"You can get an estimate of the compute units by simulating the transaction on the RPC. To avoid transaction failures caused by underestimating this limit, you can add an additional 100,000 compute units, but you can adjust this based on your own tests."}),"\n",(0,a.jsxs)(n.p,{children:["The prioritization fee per compute unit also incentivizes validators to prioritize your transaction, especially during times of network congestion. You can call the ",(0,a.jsx)(n.code,{children:"getRecentPrioritizationFees"})," RPC method to retrieve an array of 150 values, where each value represents the lowest priority fee paid for transactions that landed in each of the past 150 blocks. In this example, we sort that list and select the 50th percentile, but you can adjust this if needed. The prioritization fee is provided in micro-lamports per compute unit. The total priority fee in lamports you will pay is calculated as ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mtext,{children:"estimated\xa0compute\xa0units"}),(0,a.jsx)(n.mo,{children:"\u22c5"}),(0,a.jsx)(n.mtext,{children:"prioritization\xa0fee"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"}),(0,a.jsx)(n.mi,{mathvariant:"normal",children:"/"}),(0,a.jsxs)(n.msup,{children:[(0,a.jsx)(n.mn,{children:"10"}),(0,a.jsx)(n.mn,{children:"6"})]})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"(\\text{estimated compute units} \\cdot \\text{prioritization fee}) / 10^6"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord text",children:(0,a.jsx)(n.span,{className:"mord",children:"estimated\xa0compute\xa0units"})}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u22c5"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord text",children:(0,a.jsx)(n.span,{className:"mord",children:"prioritization\xa0fee"})}),(0,a.jsx)(n.span,{className:"mclose",children:")"}),(0,a.jsx)(n.span,{className:"mord",children:"/1"}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord",children:"0"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsx)(n.span,{className:"vlist-t",children:(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"6"})})]})})})})})]})]})]})]}),"."]}),"\n",(0,a.jsxs)(r.A,{groupId:"programming-languages",children:[(0,a.jsx)(o.A,{value:"ts",label:"Typescript",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"const getComputeUnitEstimateForTransactionMessage =\n  getComputeUnitEstimateForTransactionMessageFactory({\n    rpc\n  });\nconst computeUnitEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage) + 100_000;\nconst medianPrioritizationFee = await rpc.getRecentPrioritizationFees()\n  .send()\n  .then(fees =>\n    fees\n      .map(fee => Number(fee.prioritizationFee))\n      .sort((a, b) => a - b)\n      [Math.floor(fees.length / 2)]\n  );\nconst transactionMessageWithComputeUnitInstructions = await prependTransactionMessageInstructions([\n  getSetComputeUnitLimitInstruction({ units: computeUnitEstimate }),\n  getSetComputeUnitPriceInstruction({ microLamports: medianPrioritizationFee })\n], transactionMessage);\n"})})}),(0,a.jsx)(o.A,{value:"rust",label:"Rust",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:"#[tokio::main]\nasync fn main() {\n  // ...\n  let simulated_transaction = rpc.simulate_transaction(&transaction).await.unwrap();\n\n  let mut all_instructions = vec![];\n  if let Some(units_consumed) = simulated_transaction.value.units_consumed {\n    let units_consumed_safe = units_consumed as u32 + 100_000;\n    let compute_limit_instruction =\n      ComputeBudgetInstruction::set_compute_unit_limit(units_consumed_safe);\n    all_instructions.push(compute_limit_instruction);\n\n    let prioritization_fees = rpc\n      .get_recent_prioritization_fees(&[whirlpool_address])\n      .await\n      .unwrap();\n    let mut prioritization_fees_array: Vec<u64> = prioritization_fees\n      .iter()\n      .map(|fee| fee.prioritization_fee)\n      .collect();\n    prioritization_fees_array.sort_unstable();\n    let prioritization_fee = prioritization_fees_array\n      .get(prioritization_fees_array.len() / 2)\n      .cloned();\n\n    if let Some(prioritization_fee) = prioritization_fee {\n      let priority_fee_instruction =\n        ComputeBudgetInstruction::set_compute_unit_price(prioritization_fee);\n      all_instructions.push(priority_fee_instruction);\n    }\n  }\n  // ...\n}\n"})})})]}),"\n",(0,a.jsx)(n.h3,{id:"4-sign-and-submit-transaction",children:"4. Sign and Submit Transaction"}),"\n",(0,a.jsx)(n.p,{children:"Finally, the transaction needs to be signed, encoded, and submitted to the network. A client-side time-base retry mechanism ensures that the transaction is repeatedly sent until it is confirmed or the time runs out. We use a time-based loop, because we know that the lifetime of a transaction is 150 blocks, which on average takes about 79-80 seconds. The signing of the transactions is an idempotent operation and produces a transaction hash, which acts as the transaction ID. Since transactions can be added only once to the block chain, we can keep sending the transaction during the lifetime of the trnsaction."}),"\n",(0,a.jsxs)(n.p,{children:["You're probably wondering why we don't just use the widely used ",(0,a.jsx)(n.code,{children:"sendAndConfirm"})," method. This is because the retry mechanism of the ",(0,a.jsx)(n.code,{children:"sendAndConfirm"})," method is executed on the RPC. By default, RPC nodes will try to forward (rebroadcast) transactions to leaders every two seconds until either the transaction is finalized, or the transaction's blockhash expires. If the outstanding rebroadcast queue size is greater than 10,000 transaction, newly submitted transactions are dropped. This means that at times of congestion, your transaction might not even arrive at the RPC in the first place. Moreover, the ",(0,a.jsx)(n.code,{children:"confirmTransaction"})," RPC method that ",(0,a.jsx)(n.code,{children:"sendAndConfirm"})," calls is deprecated."]}),"\n",(0,a.jsxs)(r.A,{groupId:"programming-languages",children:[(0,a.jsx)(o.A,{value:"ts",label:"Typescript",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"const signedTransaction = await signTransactionMessageWithSigners(transactionMessageWithComputeUnitInstructions)\nconst base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\nconst timeoutMs = 90000;\nconst startTime = Date.now();\n\nwhile (Date.now() - startTime < timeoutMs) {\n  const transactionStartTime = Date.now();\n\n  const signature = await rpc.sendTransaction(base64EncodedWireTransaction, {\n    maxRetries: 0n,\n    skipPreflight: true,\n    encoding: 'base64'\n  }).send();\n\n  const statuses = await rpc.getSignatureStatuses([signature]).send();\n  if (statuses.value[0]) {\n    if (!statuses.value[0].err) {\n      console.log(`Transaction confirmed: ${signature}`);\n      break;\n    } else {\n      console.error(`Transaction failed: ${statuses.value[0].err.toString()}`);\n      break;\n    }\n  }\n\n  const elapsedTime = Date.now() - transactionStartTime;\n  const remainingTime = Math.max(0, 1000 - elapsedTime);\n  if (remainingTime > 0) {\n    await new Promise(resolve => setTimeout(resolve, remainingTime));\n  }\n}\n"})})}),(0,a.jsx)(o.A,{value:"rust",label:"Rust",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:'#[tokio::main]\nasync fn main() {\n  // ...\n  all_instructions.extend(open_position_instructions.instructions);\n  let message = Message::new(&all_instructions, Some(&wallet.pubkey()));\n\n  let transaction = Transaction::new(&signers ,message , recent_blockhash);\n  let transaction_config = RpcSendTransactionConfig {\n    skip_preflight: true,\n    preflight_commitment: Some(CommitmentLevel::Confirmed),\n    max_retries: Some(0),\n    ..Default::default()\n  };\n\n  let start_time = Instant::now();\n  let timeout = Duration::from_secs(90);\n  let send_transaction_result = loop {\n    if start_time.elapsed() >= timeout {\n      break Err(Box::<dyn std::error::Error>::from("Transaction timed out"));\n    }\n    let transaction_start_time = Instant::now();\n\n    let signature: Signature = rpc\n      .send_transaction_with_config(&transaction, transaction_config)\n      .await\n      .unwrap();\n    let statuses = rpc\n      .get_signature_statuses(&[signature])\n      .await\n      .unwrap()\n      .value;\n\n    if let Some(status) = statuses[0].clone() {\n      break Ok((status, signature));\n    }\n\n    let elapsed_time = transaction_start_time.elapsed();\n    let remaining_time = Duration::from_millis(1000).saturating_sub(elapsed_time);\n    if remaining_time > Duration::ZERO {\n      sleep(remaining_time).await;\n    }\n  };\n\n  let signature = send_transaction_result.and_then(|(status, signature)| {\n    if let Some(err) = status.err {\n      Err(Box::new(err))\n    } else {\n      Ok(signature)\n    }\n  });\n  println!("Result: {:?}", signature);\n}\n'})})})]}),"\n",(0,a.jsx)(n.h2,{id:"handling-transactions-with-wallets-in-web-apps",children:"Handling transactions with Wallets in web apps."}),"\n",(0,a.jsx)(n.h4,{id:"creating-noop-signers",children:"Creating Noop Signers"}),"\n",(0,a.jsxs)(n.p,{children:["When sending transactions from your web application, users need to sign the transaction using their wallet. Since the transaction needs to assembled beforehand, you can create a ",(0,a.jsx)(n.code,{children:"noopSigner"})," (no-operation signer) and add it to the instructions. This will act as a placeholder for you instructions, indicating that a given account is a signer and the signature wil be added later. After assembling the transaction you can pass it to the wallet extension. If the user signs, it will return a serialized transaction with the added signature."]}),"\n",(0,a.jsx)(n.h4,{id:"prioritization-fees",children:"Prioritization Fees"}),"\n",(0,a.jsx)(n.p,{children:"Some wallets will calculate and apply priority fees for your transactions, provided:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The transaction does not already have signatures present."}),"\n",(0,a.jsx)(n.li,{children:"The transaction does not have existing compute-budget instructions."}),"\n",(0,a.jsx)(n.li,{children:"The transactions will still be less than the maximum transaction size fo 1232 bytes, after applying compute-budget instructions."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"additional-improvements-for-landing-transactions",children:"Additional Improvements for Landing Transactions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"You could send your transaction to multiple RPC nodes at the same time, all within each iteration of the time-based loop."}),"\n",(0,a.jsxs)(n.li,{children:["At the time of writing, 85% of Solana validators are Jito validators. Jito validators happily accept an additional tip, in the form a SOL transfer, to prioritize a transaction. A good place to get familiarized with Jito is here: ",(0,a.jsx)(n.a,{href:"https://www.jito.network/blog/jito-solana-is-now-open-source/",children:"https://www.jito.network/blog/jito-solana-is-now-open-source/"})]}),"\n",(0,a.jsx)(n.li,{children:"Solana gives staked validators more reliable performance when sending transactions by routing them through prioritized connections. This mechanism is referred to as stake-weighted Quality of Service (swQoS). Validators can extend this service to RPC nodes, essentially giving staked connections to RPC nodes as if they were validators with that much stake in the network. RPC providers, like Helius and Titan, expose such peered RPC nodes to paid users, allowing users to send transactions to RPC nodes which use the validator's staked connections. From the RPC, the transaction is then sent over the staked connection with a lower likelihood of being delayed or dropped."}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(4041);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},4435:(e,n,t)=>{t.d(n,{A:()=>r});t(4041);var s=t(4357);const a={tabItem:"tabItem_OMyP"};var i=t(1085);function r(e){let{children:n,hidden:t,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(a.tabItem,r),hidden:t,children:n})}}}]);