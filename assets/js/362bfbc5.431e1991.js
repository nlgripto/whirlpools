"use strict";(self.webpackChunk_orca_so_whirlpools_docs=self.webpackChunk_orca_so_whirlpools_docs||[]).push([[2212],{1184:(i,e,n)=>{n.d(e,{R:()=>s,x:()=>r});var t=n(4041);const o={},a=t.createContext(o);function s(i){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof i?i(e):{...e,...i}}),[e,i])}function r(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:s(i.components),t.createElement(a.Provider,{value:e},i.children)}},5651:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Legacy SDK/Position Management/Opening a Position","title":"Opening a Position","description":"Positions in Whirlpools are tracked with a minted NFT in the user\'s wallet.","source":"@site/docs/04-Legacy SDK/03-Position Management/01-Opening a Position.md","sourceDirName":"04-Legacy SDK/03-Position Management","slug":"/Legacy SDK/Position Management/Opening a Position","permalink":"/Legacy SDK/Position Management/Opening a Position","draft":false,"unlisted":false,"editUrl":"https://github.com/orca-so/whirlpools/tree/main/docs/whirlpool/docs/04-Legacy SDK/03-Position Management/01-Opening a Position.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"sidebar","previous":{"title":"Creating a Pool","permalink":"/Legacy SDK/Managing Whirlpools/Create a Pool"},"next":{"title":"Modify Liquidity","permalink":"/Legacy SDK/Position Management/Modify Liquidity"}}');var o=n(1085),a=n(1184);const s={},r="Opening a Position",l={},c=[{value:"Opening Position with Metadata",id:"opening-position-with-metadata",level:2},{value:"Initialize Tick Array accounts if needed",id:"initialize-tick-array-accounts-if-needed",level:2},{value:"Open Position with WhirlpoolClient",id:"open-position-with-whirlpoolclient",level:2},{value:"The Manual way",id:"the-manual-way",level:2},{value:"Determine position parameters",id:"determine-position-parameters",level:2},{value:"Common Errors",id:"common-errors",level:2}];function d(i){const e={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...i.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"opening-a-position",children:"Opening a Position"})}),"\n",(0,o.jsx)(e.p,{children:"Positions in Whirlpools are tracked with a minted NFT in the user's wallet."}),"\n",(0,o.jsx)(e.p,{children:"The usual action of opening a position consists of two instruction calls"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"initializeTickArray"})," to initialize the tick arrays that would host your desired ticks for your position if they do not exist yet."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"Whirlpool.openPosition"})," or ",(0,o.jsx)(e.code,{children:"Whirlpool.openPositionWithMetadata"})," to mint the position and define the tick range"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"increaseLiquidity"})," to transfer tokens from your wallet into a position."]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"Whirlpool.openPosition"})," function now supports both traditional and Token2022-based position NFTs. To utilize Token2022, provide the Token2022 ProgramId as the ",(0,o.jsx)(e.code,{children:"tokenProgramId"})," parameter when calling ",(0,o.jsx)(e.code,{children:"openPosition"}),". This will mint the NFT using Token2022, which leverages the MetadataPointer and TokenMetadata extensions, eliminating the need for Metaplex metadata accounts."]}),"\n",(0,o.jsx)(e.h2,{id:"opening-position-with-metadata",children:"Opening Position with Metadata"}),"\n",(0,o.jsxs)(e.p,{children:["By using ",(0,o.jsx)(e.code,{children:"Whirlpool.openPositionWithMetadata"}),", users have the option of appending ",(0,o.jsx)(e.a,{href:"https://www.metaplex.com/learn-developers",children:"Metaplex metadata"})," onto the Token Program position NFT. Doing so will allow the token to be identifiable in tracking websites or wallets as a Whirlpool NFT. The drawback is it will require more compute-budget and will incurr Metaplex fees of 0.01 SOL."]}),"\n",(0,o.jsx)(e.h2,{id:"initialize-tick-array-accounts-if-needed",children:"Initialize Tick Array accounts if needed"}),"\n",(0,o.jsxs)(e.p,{children:["For liquidity to exist in the Whirlpool, the tick-array that contains that particular tick must be initialized. Calculate the start_index of the required tick array and use the ",(0,o.jsx)(e.code,{children:"initialize_tick_array"})," instruction to initialize it."]}),"\n",(0,o.jsxs)(e.p,{children:["More often than not, tick-arrays are already created. But if you want your code to be defensive, you should do a check prior to invoking ",(0,o.jsx)(e.code,{children:"open_position"}),". To understand more on how Tick-Arrays work in Whirlpools, read here."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:"const tickArrayPda = PDAUtil.getTickArray(\n  this.ctx.program.programId,\n  this.address,\n  startTick\n);\n\n// Check if tick array exists\nconst fetcher = new AccountFetcher(...);\nconst ta = await fetcher.getTickArray(tickArrayPda.publicKey, true);\n// Exit if it exists\nif (!!ta) {\n  return;\n}\n\n// Construct Init Tick Array Ix\nconst tx = toTx(ctx, WhirlpoolIx.initTickArrayIx(this.ctx.program, {\n  startTick,\n  tickArrayPda,\n  whirlpool: this.address,\n  funder: !!funder ? AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey,\n}));\nawait tx.buildAndExecute();\n"})}),"\n",(0,o.jsx)(e.h2,{id:"open-position-with-whirlpoolclient",children:"Open Position with WhirlpoolClient"}),"\n",(0,o.jsxs)(e.p,{children:["WhirlpoolClient's ",(0,o.jsx)(e.code,{children:"openPosition"})," method bundles the open and increase liquidity instructions into a single transaction for you. Below is a code sample to create a position for the SOL/USDC pool at the price between ",(0,o.jsxs)(e.span,{className:"katex",children:[(0,o.jsx)(e.span,{className:"katex-mathml",children:(0,o.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(e.semantics,{children:[(0,o.jsxs)(e.mrow,{children:[(0,o.jsx)(e.mn,{children:"98"}),(0,o.jsx)(e.mo,{children:"\u2212"})]}),(0,o.jsx)(e.annotation,{encoding:"application/x-tex",children:"98 - "})]})})}),(0,o.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,o.jsxs)(e.span,{className:"base",children:[(0,o.jsx)(e.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,o.jsx)(e.span,{className:"mord",children:"98"}),(0,o.jsx)(e.span,{className:"mord",children:"\u2212"})]})})]}),"150, with the intention to deposit 50 SOL into the position."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:"// Derive the Whirlpool address\nconst poolAddress = PDAUtil.getWhirlpool(\n    WHIRLPOOL_PROGRAM_ID,\n    ORCA_WHIRLPOOLS_CONFIG,\n    SOL_MINT,\n    USDC_MINT,\n    64\n  );\n\n// Load everything that you need\nconst client = buildWhirlpoolClient(context, fetcher);\nconst pool = await client.getPool(poolAddress.publicKey);\nconst poolData = pool.getData();\nconst poolTokenAInfo = pool.getTokenAInfo();\nconst poolTokenBInfo = pool.getTokenBInfo();\n\n// Derive the tick-indices based on a human-readable price\nconst tokenADecimal = poolTokenAInfo.decimals;\nconst tokenBDecimal = poolTokenBInfo.decimals;\nconst tickLower = TickUtil.getInitializableTickIndex(\n  PriceMath.priceToTickIndex(new Decimal(98), tokenADecimal, tokenBDecimal),\n  poolData.tickSpacing\n);\nconst tickUpper = TickUtil.getInitializableTickIndex(\n  PriceMath.priceToTickIndex(new Decimal(150), tokenADecimal, tokenBDecimal),\n  poolData.tickSpacing\n);\n\n// Get a quote on the estimated liquidity and tokenIn (50 tokenA)\nconst quote = increaseLiquidityQuoteByInputToken(\n  poolTokenAInfo.mint,\n  new Decimal(50),\n  tickLower,\n  tickUpper,\n  Percentage.fromFraction(1, 100),\n  pool\n);\n\n// Evaluate the quote if you need\nconst {tokenMaxA, tokenMaxB} = quote\n\n// Construct the open position & increase_liquidity ix and execute the transaction.\nconst { positionMint, tx } = await pool.openPosition(\n  lowerTick,\n  upperTick,\n  quote\n);\nconst txId = await tx.buildAndExecute();\n\n// Fetch the newly created position with liquidity\nconst position = await client.getPosition(\n  PDAUtil.getPosition(WHIRLPOOL_PROGRAM_ID, positionMint).publicKey\n)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"the-manual-way",children:"The Manual way"}),"\n",(0,o.jsxs)(e.p,{children:["Follow the instructions below if you would like to have more control over your instruction building process. Note that ",(0,o.jsx)(e.code,{children:"open_position"}),' does not add liquidity to a position. Follow the next article "Modify Liquidity" to add liquidity.']}),"\n",(0,o.jsx)(e.h2,{id:"determine-position-parameters",children:"Determine position parameters"}),"\n",(0,o.jsxs)(e.p,{children:["To open a position against a Whirlpool, you must first define certain parameters of your position to invoke the ",(0,o.jsx)(e.code,{children:"open_position"})," instruction."]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"WhirlpoolKey"})," - The public key for the Whirlpool that the position will host liquidity in."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"tickLowerIndex"}),", ",(0,o.jsx)(e.code,{children:"tickUpperIndex"})," - The tick index bounds for the position. Must be an initializable index."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"positionMintAddress"})," - A generated empty Keypair that will be initialized to a token mint."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"positionPda"})," -  Derived address of the position account via ",(0,o.jsx)(e.code,{children:"getPositionPda"})]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"positionTokenAccountAddress"})," - This is the account that will hold the minted position token. It is the associated token address of the position-mint."]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-tsx",children:"    const positionMintKeypair = Keypair.generate();\n    const positionPda = getPositionPda(programId, positionMintKeypair.publicKey);\n    const metadataPda = getPositionMetadataPda(positionMintKeypair.publicKey);\n    const positionTokenAccountAddress = await deriveATA(\n      provider.wallet.publicKey,\n      positionMintKeypair.publicKey\n    );\n\n    const positionIx = toTx(ctx, WhirlpoolIx.openPositionWithMetadataIx(ctx.program, {\n        funder: provider.wallet.publicKey,\n        ownerKey: provider.wallet.publicKey,\n        positionPda,\n        metadataPda,\n        positionMintAddress: positionMintKeypair.publicKey,\n        positionTokenAccountAddress,\n        whirlpoolKey: toPubKey(poolAddress),\n        tickLowerIndex,\n        tickUpperIndex,\n      })).addSigner(positionMintKeypair).buildAndExecute();\n"})}),"\n",(0,o.jsx)(e.p,{children:"Once your position is open, proceed to the next section to add liquidity."}),"\n",(0,o.jsx)(e.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"InvalidTickIndex"})," (0x177a)","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"tickLowerIndex is higher than upper tickUpperIndex"}),"\n",(0,o.jsxs)(e.li,{children:["Some tick indices is not an initializable index (not a multiple of tickSpacing). Use ",(0,o.jsx)(e.code,{children:"TickUtil.getInitializableTickIndex"})," to get the closest initializable tick to your index."]}),"\n",(0,o.jsx)(e.li,{children:"Some tick indices is out of bounds"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"NotRentExempt"})," (0x0)","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Usually, the TickArray that houses your tickLowerIndex or tickUpperIndex has not been initialized. Use the ",(0,o.jsx)(e.code,{children:"WhirlpoolClient.initTickArrayForTicks"})," or ",(0,o.jsx)(e.code,{children:"WhirlpoolIx.initTickArrayIx"})," to initialize the array at the derived startTickIndex."]}),"\n",(0,o.jsxs)(e.li,{children:["Alternatively, if this failure is from ",(0,o.jsx)(e.code,{children:"init_tick_array"}),", the tick array has already been initialized."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(i={}){const{wrapper:e}={...(0,a.R)(),...i.components};return e?(0,o.jsx)(e,{...i,children:(0,o.jsx)(d,{...i})}):d(i)}}}]);